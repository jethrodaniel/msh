# Extensions to make MRuby _compatible_ with CRuby

if RUBY_ENGINE == "mruby"
  $CHILD_STATUS = $? # rubocop:disable Style/SpecialGlobalVars
  $LOAD_PATH    = $: # rubocop:disable Style/SpecialGlobalVars

  module Kernel
    def puts obj
      $stdout.puts obj
    end

    def warn msg
      $stderr.puts msg # rubocop:disable Style/StderrPuts
    end

    def abort msg, exit_code = 1
      warn msg
      exit! exit_code
    end

    def exec cmd, *args
      env = ENV.to_h

      if (path = ENV["PATH"]).include? ":"
        p = path.split(":").find do |p|
          f = File.join(p, cmd)
          File.file?(f) # && File.executable?(f) && !File.directory?(f)
        end
        if p
          exe = File.join(p, cmd)
          return Exec.execve(env, exe, *args)
        end
      end

      Exec.execve(env, cmd, *args)
    end

    def fork &block
      Process.fork(&block)
    end
  end

  class Dir
    # mruby-dir doesn't provide this
    def self.home
      ENV["HOME"]
    end

    def self.pwd
      ENV["PWD"]
    end
  end

  module Process
    class << self
      alias wait waitpid
    end
  end

  ENV.instance_eval do
    alias to_h to_hash
  end

  def __main__ _argv
    Msh.start
  end
end
#!/usr/bin/env ruby


# Autogenerated single-file version of `lib/msh.rb`.
#
# Each file is present below, but
#
# - standard library `require`s are moved to **before** the file. TODO: fix this.
# - `require`s for non-standard library files are absent (obviously)
#
require 'English' unless RUBY_ENGINE == 'mruby'

#+----------------- `lib/msh/backports.rb`
# Backports for nice things.

version = RUBY_VERSION[0..2].to_f

if version <= 2.7
  ENV.instance_eval do
    if RUBY_ENGINE == "mruby"
      def merge! hsh
        hsh.each { |k, v| ENV[k] = v }
      end
    else
      alias merge! update
    end
  end
end

if version <= 2.6
  class Binding
    def source_location
      self.eval "[__FILE__, __LINE__]"
    end
  end
end

if version <= 2.5
  class String
    def delete_suffix suffix
      self[0..size - suffix.size - 1]
    end
  end

  class Pathname
    def glob glob
      Dir.glob(glob)
    end
  end

  class Array
    alias prepend unshift
  end

  class Symbol
    def start_with? prefix
      to_s.start_with? prefix
    end
  end
end
#+----------------------------------------

#+----------------- `lib/msh/core_extensions.rb`
class Object
  def self.delegate meth, obj, via: nil
    define_method meth do
      send(obj).send(via || meth)
    end
  end
end
#+----------------------------------------------

#+----------------- `lib/msh/version.rb`
module Msh
  VERSION = "0.2.0"
end
#+--------------------------------------

#+----------------- `lib/msh/optparse.rb`
module Msh
  # Stupid simple option parser _clone_, since optparse is pretty heavyweight,
  # and pulls in onigmo (regexp) on mruby.
  class OptionParser
    class MissingArgument < ArgumentError; end
    class InvalidOption < ArgumentError; end

    Action = Struct.new(:short, :long, :desc, :block) do
      def help_line_opts
        "    #{short}, #{long}"
      end
    end

    attr_accessor :banner

    def initialize
      @actions = []
      @banner = nil
      yield self if block_given?
    end

    def to_s
      longest_opts = @actions.max_by { |a| a.help_line_opts.size }
                             .help_line_opts
                             .size + 2
      lines = []

      @actions.sort_by { |a| [a.short, a.long] }.each do |a|
        lines << a.help_line_opts.ljust(longest_opts, " ") + a.desc
      end

      lines.join("\n")
    end

    def on short, long, desc, &block
      @actions << Action.new(short, long, desc, block)
    end

    def parse!
      switches, files = ARGV.partition { |e| e.start_with?("-") }

      switches.each do |switch|
        action = if switch.start_with?("--")
                   @actions.find { |a| a.long == switch }
                 else
                   @actions.find { |a| a.short == switch }
                 end

        if action
          puts(@banner) if action.long == "--help"
          action.block.(files.join(" "))
        else
          raise InvalidOption, "invalid option `#{switch}`"
        end
      end
    end
  end
end
#+---------------------------------------
require 'logger' unless RUBY_ENGINE == 'mruby'

#+----------------- `lib/msh/errors.rb`
module Msh
  module Errors
    class Error < StandardError; end
    class ParseError       < Error; end
    class InterpreterError < Error; end
    class LexerError       < Error; end
    class ReplError        < Error; end
    class LoggerError      < Error; end
  end
end
#+-------------------------------------

#+----------------- `lib/msh/ansi.rb`
# Adapted from https://stackoverflow.com/a/11482430/7132678
class String
  def black
    "\e[30m#{self}\e[0m"
  end

  def red
    "\e[31m#{self}\e[0m"
  end

  def green
    "\e[32m#{self}\e[0m"
  end

  def brown
    "\e[33m#{self}\e[0m"
  end

  def blue
    "\e[34m#{self}\e[0m"
  end

  def magenta
    "\e[35m#{self}\e[0m"
  end

  def cyan
    "\e[36m#{self}\e[0m"
  end

  def gray
    "\e[37m#{self}\e[0m"
  end

  def bg_black
    "\e[40m#{self}\e[0m"
  end

  def bg_red
    "\e[41m#{self}\e[0m"
  end

  def bg_green
    "\e[42m#{self}\e[0m"
  end

  def bg_brown
    "\e[43m#{self}\e[0m"
  end

  def bg_blue
    "\e[44m#{self}\e[0m"
  end

  def bg_magenta
    "\e[45m#{self}\e[0m"
  end

  def bg_cyan
    "\e[46m#{self}\e[0m"
  end

  def bg_gray
    "\e[47m#{self}\e[0m"
  end

  def bold
    "\e[1m#{self}\e[22m"
  end

  def italic
    "\e[3m#{self}\e[23m"
  end

  def underline
    "\e[4m#{self}\e[24m"
  end

  def blink
    "\e[5m#{self}\e[25m"
  end

  def reverse_color
    "\e[7m#{self}\e[27m"
  end

  def no_colors
    gsub /\e\[\d+m/, ""
  end
end
#+-----------------------------------

#+----------------- `lib/msh/logger.rb`
module Msh
  module Logger
    FORMATTER = -> severity, time, _progname, msg do
      color = case severity
              when "DEBUG" then :magenta
              when "INFO" then :green
              when "WARN" then :cyan
              when "ERROR" then :red
              when "FATAL", "UNKNOWN" then :red
              else
                raise Msh::Logger::Error, "invalid log level: #{severity}"
              end

      severity = severity.send(color).bold
      time = time.to_s.green.bold

      "[#{severity.ljust(5, ' ')}][#{time}]: #{msg}\n"
    end

    # Access a logger, to stdout (for now).
    #
    # Uses logging level ENV['MSH_LOG'], which can be WARN, INFO, etc
    def log
      logger = ::Logger.new $stdout

      logger.formatter = FORMATTER
      logger.level = log_level

      logger
    end

    def log_level
      case severity = ENV["MSH_LOG"].to_s.downcase
      when "debug"
        ::Logger::DEBUG
      when "info"
        ::Logger::INFO
      when "warn"
        ::Logger::WARN
      when "error"
        ::Logger::ERROR
      when "fatal"
        ::Logger::FATAL
      when "unknown"
        ::Logger::UNKNOWN
      else
        6 # Some large positive, so we don't log anything
      end
    end
  end
end
#+-------------------------------------

#+----------------- `lib/msh/config.rb`
module Msh
  # Configure Msh.
  #
  # The user's config file is the first of
  #
  # - `~/.mshrc`
  # - `$XDG_CONFIG_HOME/msh/config.rb`
  # - `~/.config/msh/config.rb`
  #
  # @example
  #     Msh.configure do |c|
  #       c.repl = :pry
  #     end
  #     Msh.config.repl #=> :pry
  #     Msh.config.color #=> true
  class Config
    # @return [bool] whether color is enabled (default: true)
    attr_accessor :color

    # @return [Integer] lines of history to keep (default: 2,048)
    attr_accessor :history_lines

    # @note This will call `binding.send :repl` for the provided repl
    # @return [Symbol] what kind of repl to use, IRB or Pry (default: :irb)
    attr_accessor :repl

    # @return [String]
    attr_accessor :file

    def initialize
      @color = true
      @history_lines = 2_048
      @repl = :irb # :pry
    end

    # Load first config file with `load`
    def self.load!
      paths = []

      paths << File.join(ENV["XDG_CONFIG_HOME"], "msh/config.rb") if ENV.key? "XDG_CONFIG_HOME"

      paths += [
        File.join(Dir.home, ".mshrc"),
        File.join(Dir.home, ".config/msh/config.rb")
      ]

      load @file if @file = paths.find { |p| File.exist? p }
    end
  end

  # Configure Msh with a block
  #
  # ```
  # Msh.configure do |c|
  #   c.repl = :pry
  # end
  # ```
  def self.configure
    yield config if block_given?
  end

  # Access Msh's config
  def self.config
    @config ||= Msh::Config.new
  end
end
#+-------------------------------------

#+----------------- `lib/msh/context.rb`
module Msh
  class Context
    NEEDED = [
      # to see if our context can handle this, or should we call an executable?
      :respond_to?,

      # I assume we need these for sanity reasons?
      #
      #     BasicObject.instance_methods
      #     #=> [:__send__, :!, :==, :!=, :equal?, :__id__, :instance_eval, :instance_exec]
      #
      *BasicObject.instance_methods,

      # warning: undefining `object_id' may cause serious problems
      :object_id,

      # to check the arity of methods
      :method,

      # see what's available
      :methods,

      # `__send__` is syntactic vinegar
      :send,

      # eval is the heart and soul of msh
      :eval,
      :class_eval,

      # pry/irb/eval need these
      :is_a?,
      :to_s,
      :class,

      # Useful stuff
      :puts,
      :fork,
      :exec,
      :abort,
      :warn,
      :exit!
    ].freeze

    HIDDEN = instance_methods - NEEDED

    HIDDEN.each { |m| undef_method m }

    def hi name
      puts "hello, #{name}"
    end

    def prompt
      # "$ "
      # "#{_ || '?'} " + Dir.pwd.gsub(ENV["HOME"], "~").green + " λ ".magenta.bold
      Dir.pwd.gsub(ENV["HOME"], "~").green + " λ ".magenta.bold
    end

    def run cmd, *args
      pid = fork do
        exec cmd, *args
      rescue Errno::ENOENT => e # No such file or directory
        abort e.message
      end
      Process.wait pid
      $?.exitstatus # rubocop:disable Style/SpecialGlobalVars
    end

    attr_reader :_
    alias :$? _

    def repl
      puts "enter some ruby (sorry, no multiline)"
      loop do
        print "> "
        line = gets
        return if line.nil?

        @_ = instance_eval(line)

        puts "=> #{_.inspect}"
      end
    end

    def parser *files
      Msh::Parser.start files
      0
    end

    def lexer *files
      Msh::Lexer.start files
      0
    end

    # alias _exit exit
    def quit code = 1
      puts "goodbye! <3"
      exit! code
    end
    alias exit quit
    alias q quit

    def cd dir = nil
      last = ENV["OLDPWD"]
      ENV["OLDPWD"] = Dir.pwd
      case dir
      when "-"
        unless last
          puts "`OLDPWD` not yet set!"
          return 1
        end

        Dir.chdir last
      when nil
        Dir.chdir ENV["HOME"]
      else
        Dir.chdir dir
      end
      ENV["PWD"] = Dir.pwd
      0
    end

    def help *topics
      cmd = if topics.empty?
              %w[man msh]
            else
              %w[man] + topics.map { |t| "msh-#{t}" }
            end

      pid = fork do
        exec(*cmd)
      rescue Errno::ENOENT => e # No such file or directory
        abort e.message
      end

      Process.wait pid

      $CHILD_STATUS.exitstatus
    end
    alias_method :'?', :help # rubocop:disable Style/Alias (ruby can't parse this)
  end
end
#+--------------------------------------

#+----------------- `lib/msh/evaluator.rb`
module Msh
  class Evaluator
    def initialize
      @context = Context.new
    end

    def _call meth, *args, &block
      case @context.instance_eval { method(meth).arity }
      when 0
        @context.send meth, &block
      else
        @context.send meth, *args, &block
      end
    end
    alias call_no_exit_value _call

    def call meth, *args, &block
      ret = _call meth, *args, &block
      @context.instance_eval { @_ = ret }
      ret
    end

    def eval code
      ret = @context.instance_eval code
      @context.instance_eval { @_ = ret }
      ret
    end

    def has? meth
      @context.respond_to? meth
    end
  end
end
#+----------------------------------------
require 'reline' unless RUBY_ENGINE == 'mruby'

#+----------------- `lib/msh/readline.rb`
module Msh
  module Readline
    def self.readline prompt, keep_history = true
      if Object.const_defined? :Reline
        ::Reline.readline(prompt, keep_history)
      else
        print prompt
        gets&.chomp
      end
    end

    def self.add_to_history line
      return if ENV["NO_READLINE"] || RUBY_ENGINE == "mruby"

      # don't add blank lines or duplicates to history
      return unless /\A\s+\z/ =~ line || ::Reline::HISTORY.to_a.dig(-2) == line

      ::Reline::HISTORY.pop
    end
  end
end
#+---------------------------------------

#+----------------- `lib/msh/token.rb`
module Msh
  # A Token is the smallest unit of source code recognized.
  #
  # By definition, they contain a token type, and the accompanying text
  # from the input. We also add useful things such as the line and column
  # numbers, which we use in the print output.
  #
  # With line and column numbers, given a list of tokens, we should be
  # able to reconstruct the orignal input (without comments).
  #
  # ```
  # Token.new.tap do |t|
  #   t.type = :WORD
  #   t.value = "echo"
  #   t.column = 1
  #   t.line = 4
  # end #=> [1:4-8][WORD, 'echo']
  # ```
  class Token
    attr_accessor :type, :value, :line, :column

    # @return [Boolean]
    attr_accessor :valid

    # @param opts [Hash<Symbol, Integer>]
    # @option type [Symbol]
    # @option value [String]
    # @option line [Integer]
    # @option column [Integer]
    def initialize opts = {}
      @type   = opts[:type]
      @value  = opts[:value] || "" # so we can `+=` characters to this
      @line   = opts[:line]
      @column = opts[:column]
      @valid  = false
    end

    # @return [String]
    def to_s
      lexeme_end = @value.size.zero? ? @column : @column + @value&.size - 1
      value = if @type == :EOF
                # RUBY_ENGINE.include?("mruby") ? '"\x00"' : '"\\u0000"'
                '"\\u0000"'
              else
                @value.inspect
              end
      "[#{@line}:#{@column}-#{lexeme_end}][#{@type}, #{value}]"
    end

    # @param other [Token]
    # @return [bool]
    def == other
      @line == other.line \
        && @column == other.column \
        && @value == other.value \
        && @type == other.type \
        && @valid == other.valid
    end

    # @return [Boolean] whether this token is completed and valid
    def valid?
      @valid
    end
  end
end
#+------------------------------------

#+----------------- `lib/msh/scanner.rb`
module Msh
  # Basically a simple `StringScanner`
  #
  #
  class Scanner
    attr_reader :line, :column, :pos

    def initialize string
      @string = string.freeze
      @pos = 0
      @line = 1
      @column = 1
      @last_column = 1
    end

    # @note advances the scanner head
    # @return [String] the next character, EOF char if at the end of input
    def advance
      raise "pos is less than zero (#{@pos})" if @pos.negative?

      c = @string[@pos]
      @pos += 1

      if c == "\n"
        @line += 1
        @last_column = @column
        @column = 1
      else
        @column += 1
      end

      c || "\0"
    end

    # def backup
    #   if current_char == "\n"
    #     @line -= 1
    #     @column = @last_column
    #   else
    #     @column -= 1
    #   end
    #   @curr -= 1
    #   current_char
    # end

    # FIXME: this is causing an issue with the new scanner class
    # @param n [Integer]
    # @return [String, nil] nth character past the scanner head
    def peek n = 1 # rubocop:disable Naming/MethodParameterName
      start = @pos + 1
      c = @string[start...start + n]
      c.nil? || c.empty? ? "\0" : c
    end

    # @return [Boolean]
    def eof?
      current_char == "\0"
    end

    # @return [String] the character under the scanner head, or EOF if at end
    def current_char
      raise "pos is less than zero (#{@pos})" if @pos.negative?

      @string[@pos].freeze || "\0"
    end
  end
end
#+--------------------------------------

#+----------------- `lib/msh/lexer.rb`
module Msh
  # The lexer breaks down input text into a series of tokens.
  #
  # By definition, a token contains a type (which token), and a value (the
  # matched string). They also usually contain line and column number
  # information, and other metadata as well. See {Msh::Token}.
  #
  # A lexer operates like so:
  #
  # - As long as input is available, grab the next character
  # - Attempt to match a token
  #
  # The match attempt logic is {#next_token}, which is just a a big switch
  # statement on the next character, more or less.
  #
  # Note: this lexer is lossless, i.e, the completed tokens contain the entire
  # source code, including tabs, spaces, and comments.
  #
  # @example
  #   lexer = Msh::Lexer.new "a | b > c"
  #   tokens = [
  #     "[1:1-1][WORD, \"a\"]",
  #     "[1:2-2][SPACE, \" \"]",
  #     "[1:3-3][PIPE, \"|\"]",
  #     "[1:4-4][SPACE, \" \"]",
  #     "[1:5-5][WORD, \"b\"]",
  #     "[1:6-6][SPACE, \" \"]",
  #     "[1:7-7][REDIRECT_OUT, \">\"]",
  #     "[1:8-8][SPACE, \" \"]",
  #     "[1:9-9][WORD, \"c\"]",
  #     "[1:10-10][EOF, \"\\u0000\"]"
  #   ]
  #   lexer.tokens.map(&:to_s) == tokens #=> true
  class Lexer
    include Msh::Logger
    extend Msh::Logger

    # TODO: there's def more of these
    NON_WORD_CHARS = [
      "\0",
      "#",
      " ",
      "=",
      "$",
      "\t",
      "\n",
      "&",
      "|",
      "<", ">",
      "(", ")",
      "{", "}",
      ";"
    ].freeze

    DIGITS = %(0 1 2 3 4 5 6 7 8 9)

    # @return [Integer] the current line
    attr_reader :line

    # @return [Integer] the current column
    attr_reader :column

    # @param input [String]
    def initialize input
      @scanner = Scanner.new input
      @tokens  = []
      @token   = Token.new
    end

    # Run the lexer on the input until we collect all the tokens.
    #
    # @return [Array<Msh::Token>] all tokens in the input
    def tokens
      next_token until @tokens.last&.type == :EOF
      @tokens
    end

    # @return [Token, nil] the next token, or nil if not complete or at EOF
    def next_token
      reset_and_set_start

      case advance
      when "\0"
        error "out of input" if @tokens.last&.type == :EOF
        # set_token_start
        @token.type = :EOF
      when "#"
        case @scanner.current_char
        when "{"
          consume_interpolation
        else
          @token.type = :COMMENT
          advance until ["\n", "\0"].include? @scanner.current_char
        end
      when "="
        @token.type = :EQ
      when "$"
        @token.type = :VAR
        advance until NON_WORD_CHARS.include? @scanner.current_char
      when " ", "\t" # skip whitespace
        consume_whitespace
      when "\n" # newlines
        @token.type = :NEWLINE
      when ";"
        @token.type = :SEMI
      when "{"
        @token.type = :LEFT_BRACE
      when "}"
        @token.type = :RIGHT_BRACE
      when "("
        @token.type = :LEFT_PAREN
      when ")"
        @token.type = :RIGHT_PAREN
      when "!"
        @token.type = :BANG
      when "&"
        if @scanner.current_char == "&"
          advance
          @token.type = :AND
        elsif @scanner.peek(2) == ">>"
          2.times { advance }
          @token.type = :AND_D_REDIRECT_RIGHT
        elsif @scanner.current_char == ">"
          advance
          @token.type = :AND_REDIRECT_RIGHT
        else
          @token.type = :BG
        end
      when ">"
        consume_redir_right
      when "<"
        consume_redir_left
      when "|"
        case @scanner.current_char
        when "|"
          advance
          @token.type = :OR
        when "&"
          advance
          @token.type = :PIPE_AND
        else
          @token.type = :PIPE
        end
      when "1".."9"
        advance while DIGITS.include?(@scanner.current_char)

        if @scanner.current_char == ">"
          advance
          consume_redir_right
        elsif @scanner.current_char == "<"
          advance
          consume_redir_left
        else
          consume_word
        end
      else
        if @token.value          == "t" &&
           @scanner.peek(3)      == "ime"
          # TODO: `time -p` here? Pretty sure this needs to be handled by
          # the parser. Or some hideous lexer state here.
          #
          # That is, we need this for the `-p` option
          #
          # ```
          # 1. [TIME, "time"]
          # 2. [SPACE, "..."]
          # 3. [WORD, "-p"]
          # ```
          3.times { advance }
          @token.type = :TIME
        elsif @token.value == "i" && @scanner.current_char == "f"
          advance
          @token.type = :IF
        elsif @token.value == "t" && @scanner.peek(3) == "hen"
          3.times { advance }
          @token.type = :THEN
        elsif @token.value == "e" && @scanner.peek(3) == "lse"
          3.times { advance }
          @token.type = :ELSE
        elsif @token.value == "e" && @scanner.peek(2) == "nd"
          2.times { advance }
          @token.type = :END
        else
          consume_word
        end
      end

      return next_token if @token.type.nil?

      @token.type = :LAST_STATUS if @token.type == :VAR && @token.value == "$?"

      @tokens << @token.dup.freeze
      @token
    end

    # {Scanner#eof?} but in such a way that you still get true when the next
    # token is an EOF
    #
    # @return [Boolean] whether the last token is *not* an EOF
    def next?
      @tokens.last&.type != :EOF
    end

    def eof?
      !next?
    end

    # @return [Token, nil]
    def current_token
      @tokens.last
    end

    # Run the lexer interactively, i.e, run a loop and tokenize user input.
    def self.interactive
      log.info { "msh v#{Msh::VERSION}" }
      while line = Msh::Readline.readline("lexer> ", true)
        case line
        when "q", "quit", "exit"
          puts "goodbye! <3"
          return
        else
          begin
            puts Msh::Lexer.new(line).tokens.map(&:to_s)
          rescue Errors::LexerError => e
            puts e.message
          end
        end
      end
    end

    # Run the lexer on a file, and print all of it's tokens.
    def self.lex_file filename
      puts new(File.read(filename)).tokens
    rescue Errors::LexerError => e
      puts e.message
    end

    # Run the lexer, either on all files passed to ARGV, or interactively, if
    # no files are supplied. Aborts program on error.
    def self.start files = ARGV
      return Lexer.interactive if files.empty?

      files.each do |file|
        raise Errors::LexerError, "#{file} is not a file!" unless File.file? file

        puts Lexer.new(File.read(file)).tokens.map(&:to_s).join("\n")
      end
    end

    private

    # Raise an error with helpful output.
    #
    # @raise [Errors::LexerError]
    def error msg = nil
      raise Errors::LexerError, "error at line #{@token.line}, " \
                                "column #{@token.column}: #{msg}"
    end

    def set_token_start
      @token.line = @scanner.line
      @token.column = @scanner.column
    end

    # nils out all of our current token's fields
    #
    # @return [Token]
    def reset_token
      @token.tap do |t|
        t.type   = nil
        t.value  = ""
        t.line   = nil
        t.column = nil
      end
    end

    def reset_and_set_start
      reset_token
      set_token_start
    end

    def advance
      c = @scanner.advance
      @token.value += c
      c
    end

    ## Back the lexer up one character.
    ##
    ## @return [Integer] the current position index in input
    # def backup
    #  c = @scanner.backup
    #  @token.value = @token.value[0...-1]
    #  c
    # end

    # @note we've just seen a `#`
    #
    # Start at the `{` of a `#{...}`, gredily match a `}` such that we have
    # paired braces.
    #
    # ```
    # #{{} # fails, unterminated string interpolation at line 1, column 2
    # #{}} # `}` this will syntax error when we eventually eval it
    # ```
    #
    # this has the unfortunate consequence of treating the left and right
    # braces differently, as seen above. The only way to _actually_ fix this
    # is to parse the ruby expression inside the interpolation.
    def consume_interpolation
      line = @scanner.line
      col = @scanner.column - 1 # we already saw the `#`
      l_brace_stack = []

      while c = advance # loop until closing `}`
        case c
        when "{"
          l_brace_stack << c
        when "}"
          break if l_brace_stack.empty?

          l_brace_stack.pop
        end
        break if l_brace_stack.empty? || @scanner.eof?
      end

      if l_brace_stack.size.positive? # || c.nil? || eof?
        error "unterminated string interpolation, expected `}` to complete `{` at line #{line}, column #{col}"
      end

      @token.type = :INTERP
      @token.column = col
      @token.line = line
    end

    # @note we've just seen either a ` ` or a `\t`
    def consume_whitespace
      @token.type = :SPACE
      return if @scanner.current_char == "\0"

      while @scanner.current_char == " " ||
            @scanner.current_char == "\t"
        advance
      end
    end

    # @note we've just seen a `>`
    def consume_redir_right
      case @scanner.current_char
      when ">"
        advance
        @token.type = :APPEND_OUT
      when "|"
        advance
        @token.type = :NO_CLOBBER
      else
        if @scanner.current_char == "&"
          advance
          advance while DIGITS.include?(@scanner.current_char)
          @token.type = :DUP_OUT_FD
        else
          @token.type = :REDIRECT_OUT
        end
      end
    end

    # @note we've just seen a `<`
    def consume_redir_left
      case @scanner.current_char
      when "&"
        # TODO: no regex
        # if @scanner.peek(3).match? /&\d+-/
        if @scanner.peek == "&" && DIGITS.include?(@scanner.peek(3)[1..-2]) && @scanner.peek(3)[2] == "-"
          3.times { advance }
          @token.type = :MOVE
        else
          advance
          advance while DIGITS.include?(@scanner.current_char)
          @token.type = :DUP_IN_FD
        end
      when ">"
        advance
        @token.type = :OPEN_RW
      else
        @token.type = :REDIRECT_IN
      end
    end

    # @note we've just seen the first character of a WORD
    def consume_word
      advance until NON_WORD_CHARS.include?(@scanner.current_char)
      @token.type = :WORD
    end
  end
end
#+------------------------------------

#+----------------- `lib/msh/ast.rb`
# Minimal version of whitequark's excellent AST library: https://github.com/whitequark/ast
#
#     
#
#     include AST:Sexp
#     s(:DIG, 10) #=> AST::Node.new(:DIG, 10)
#
# Seriously, use whitequark's if you can.
#
module Msh
  module AST
    class Node
      attr_reader :type, :children
      alias to_a children

      attr_reader :line, :column

      def initialize type, children, **opts
        @type = type
        @children = children
        opts.each { |k, v| instance_variable_set :"@#{k}", v }
      end

      def inspect indent = 0
        indented = "  " * indent
        sexp = "#{indented}s(:#{@type}"

        children.each do |child|
          sexp += if child.is_a?(Node)
                    ",\n#{child.inspect(indent + 1)}"
                  else
                    ", #{child.inspect}"
                  end
        end

        sexp += ")"

        sexp
      end
    end

    module Sexp
      def s type, *children
        Node.new type, children
      end
    end
  end
end
#+----------------------------------

#+----------------- `lib/msh/parser.rb`
module Msh
  # The parser converts a series of tokens into an abstract syntax tree (AST).
  #
  # @example
  #     parser = Msh::Parser.new "fortune | cowsay"
  #     ast = \
  #       s(:PROG,
  #         s(:EXPR,
  #           s(:PIPELINE,
  #             s(:CMD,
  #               s(:WORD,
  #                 s(:LIT, "fortune"))),
  #             s(:CMD,
  #               s(:WORD,
  #                 s(:LIT, "cowsay"))))))
  #     parser.parse == ast #=> true
  #
  # The grammar parsed is as follows
  #
  # ```
  # # basic EBNF-like notation with comments. Tokens are UPCASE.
  # #
  # # # comments after `#`
  # # rule -> production_1 TOKEN
  # #       | production_2
  # #       | {a} # zero or more times
  # #       | {a}+ # one or more times
  # #       | # empty
  # #
  # # {...} leads to while-loops
  # # .. | .. leads to if-else/case
  #
  # #
  # # basics
  # #
  #
  # spaces -> SPACE spaces
  #         | SPACE
  #
  # _ -> spaces
  #    |
  #
  # #
  # # start of grammar
  # #
  #
  # statement -> _
  #
  # # _ if_statement
  # stat -> _ comments
  #       | _ exprs
  #       | EOF
  #
  # comments -> COMMENT NEWLINE comments
  #           | COMMENT
  #
  # exprs -> expr _ SEMI _ expr
  #        | expr _ {SEMI}
  #
  # expr -> and_or
  #       | pipeline
  #
  # and_or -> pipeline AND pipeline
  #         | pipeline OR pipeline
  #
  # pipeline -> command _ PIPE _ pipeline
  #           | command
  #
  # command -> cmd_part _ command
  #          | cmd_part
  #
  # cmd_part -> redirect | word | assignment
  #
  # assignment -> word _ EQ _ word
  #
  # #                 | No whitespace here
  # #                 |
  # word -> word_type  word
  #       | word_type
  #
  # # note: the lexer will never output `LIT LIT`
  # word_type -> LIT      # echo
  #            | INTERP   # #{Time.now}
  #            | SUB      # $(date)
  #            | VAR      # $USER
  #
  # redirect -> REDIRECT_OUT          # [n]>
  #           | REDIRECT_IN           # [n]<
  #           | APPEND_OUT            # [n]>>
  #           | AND_REDIRECT_RIGHT    # [n]&>
  #           | AND_D_REDIRECT_RIGHT  # [n]&>>
  #           | DUP_OUT_FD            # [n]>&n
  #           | DUP_IN_FD             # [n]<&n
  #           | NO_CLOBBER            # [n]>|
  # ```
  #
  # This implementation is a recursive descent parser, which starts matching at
  # the root of the grammar, then dispatches to methods for each production.
  # More specifically, there is a parse method for each non-terminal symbol,
  # and terminal symbols on the right-hand side of a rule consume themselves
  # from the input.
  #
  # Each parsing method returns an AST - we collect these as we traverse the
  # tokens, to build up the final AST.
  #
  # Note: Parse methods here use are underscore-prefixed.
  class Parser
    include Msh::Logger

    REDIRECTS = [
      :REDIRECT_OUT,         # [n]>
      :REDIRECT_IN,          # [n]<
      :APPEND_OUT,           # [n]>>
      :AND_REDIRECT_RIGHT,   # [n]&>
      :AND_D_REDIRECT_RIGHT, # [n]&>>
      :DUP_OUT_FD,           # [n]>&n
      :DUP_IN_FD,            # [n]<&n
      :NO_CLOBBER            # [n]>|
    ].freeze

    WORDS = [
      :WORD,        # echo
      :TIME,        # echo time
      :VAR,         # $USER
      :INTERP,      # echo the time is #{Time.now}
      :LAST_STATUS  # $?
    ]#.freeze

    attr_reader :lexer

    def initialize code
      @lexer = Msh::Lexer.new(code).tap(&:next_token)
    end

    delegate :current_token, :lexer
    delegate :advance,       :lexer,         :via => :next_token
    delegate :eof?,          :lexer
    delegate :line,          :current_token
    delegate :column,        :current_token

    # @raise [Error]
    def error msg = nil
      raise Errors::ParseError, "error at line #{line}, column #{column}: #{msg}"
    end

    # @param types [Array<Symbol>]
    # @return [bool]
    def match? *types
      log.debug { "  match? #{types} | #{current_token} =#{types.include? current_token.type}" }
      types.include? current_token.type
    end

    # @param types [Array<Symbol>]
    # @param msg [String]
    def consume *types, msg
      if match?(*types)
        t = current_token
        advance
        return t
      end

      error msg
    end

    # DSL to create an AST node, like {::AST::Sexp}, but adds line/column info.
    #
    # @param type [Symbol]
    # @param children [Array]
    # @return [Msh::AST::Node]
    def s type, *children
      Msh::AST::Node.new type, children, :line => line, :column => column
    end

    def self.skip_rule name, *types
      define_method "_skip_#{name}" do |*other_types|
        advance while match?(*types, *other_types)
      end
    end

    skip_rule :whitespace, :SPACE
    skip_rule :comments,   :COMMENT
    skip_rule :newlines,   :NEWLINE
    skip_rule :ignored,    :SPACE, :COMMENT, :NEWLINE
    skip_rule :ignored_no_newline, :SPACE, :COMMENT

    # Parse all tokens into an AST
    #
    # @return [AST]
    def parse
      _program
    end

    # @return [AST]
    def _program
      _skip_ignored :NEWLINE

      return s(:NOOP) if eof?

      parts = []

      parts += _exprs.children until eof?

      s(:PROG, *parts)
    end

    # @return [AST] :EXPRS
    def _exprs
      exprs = []

      until eof? || match?(:SEMI, :NEWLINE)
        exprs << _expr
        _skip_ignored_no_newline

        next unless match? :SEMI, :NEWLINE

        advance

        _skip_ignored_no_newline
      end

      _skip_ignored

      s(:EXPRS, *exprs)
    end

    # @return [AST] :EXPR
    def _expr
      c = _pipeline

      _skip_ignored_no_newline

      if match? :AND, :OR
        op = consume :AND, :OR, "expected an `&&` or an `||`"
        _skip_whitespace
        right = _pipeline
        return s(:EXPR, s(op.type, c, right))
      end

      return s(:EXPR, s(:PIPELINE, c, *_pipeline.children)) if match? :PIPE

      s(:EXPR, c)
    end

    # @return [AST] :ASSIGN, :WORD
    def _command
      cmd_parts = []

      while match?(*WORDS, *REDIRECTS)
        if match?(*REDIRECTS) && match?(*WORDS)
          error "current token is both a redrect and a word? #{current_token}"
        end

        if match?(*WORDS)
          cmd_parts << _word
        elsif match?(*REDIRECTS)
          cmd_parts << _redirect
        end
        _skip_whitespace

        next unless match? :EQ

        consume :EQ, "expected an `=`"
        _skip_whitespace
        error "missing value for variable assignment" unless match?(*WORDS)
        cmd_parts << s(:ASSIGN, cmd_parts.pop, _word)
        _skip_whitespace

        break if eof? || match?(:NEWLINE)

        error "expected a word, got #{current_token}" unless match?(*WORDS, *REDIRECTS)
      end

      error "expected a word or redirect" if cmd_parts.empty?

      s(:CMD, *cmd_parts)
    end

    # @return [AST] :WORD
    def _word
      log.debug { ":#{__method__}: #{current_token} | match?(*WORDS): #{match?(*WORDS)} | match?(*REDIRECTS): #{match?(*REDIRECTS)}" }
      # log.debug { "#{__method__}: #{current_token}" }

      word_pieces = []

      # somehow mruby is matching redirects **and** words..
      while match?(*WORDS)
        c = current_token
        # log.debug { ":#{__method__}: #{current_token} | match?(*WORDS): #{match?(*WORDS)} | match?(*REDIRECTS): #{match?(*REDIRECTS)}" }
        # log.debug { "  2#{__method__}: #{current_token}" }
        # log.debug { "  2#{__method__}: #{current_token.type.inspect} | match?(*WORDS): #{match?(*WORDS)} | match?(*REDIRECTS): #{match?(*REDIRECTS)}" }
        # next if  # why?

        case c.type
        when :WORD, :TIME
          word_pieces << s(:LIT, c.value)
        when :INTERP
          word_pieces << s(:INTERP, c.value)
        when :VAR
          word_pieces << s(:VAR, c.value)
        when :LAST_STATUS
          word_pieces << s(:LAST_STATUS, c.value)
        else
          error "expected a word type, got `#{current_token}`"
        end
        # log.debug { "-> #{current_token} | match?(*REDIRECTS):#{match?(*REDIRECTS)} | match?(*WORDS): #{match?(*WORDS)} " }

        advance
        # break unless match? :WORD
        # log.debug { p "-> #{current_token} | match?(*REDIRECTS):#{match?(*REDIRECTS)} | match?(*WORDS): #{match?(*WORDS)} "}
      end

      error "expected a word" if word_pieces.empty?

      s(:WORD, *word_pieces)
    end

    # @return [AST]
    def _redirect
      # r = consume(:REDIRECT_OUT, "expected a redirection operator")
      r = consume(*REDIRECTS, "expected a redirection operator")
      n = r.value.match(/\A(\d+)/)&.captures&.first&.to_i

      _skip_whitespace

      case r.type
      when :DUP_OUT_FD # 2>&1
        s(:REDIRECT, n, r.type)
      else
        # f = consume(*WORDS, "expected a filename to complete redirection #{r}")
        f = consume(:WORD, "expected a filename to complete redirection #{r}")

        case r.type
        when :REDIRECT_OUT, :APPEND_OUT, :AND_REDIRECT_RIGHT
          n ||= 1
        when :REDIRECT_IN
          n ||= 0
        else
          error "unknown redirection type `#{r}`"
        end

        s(:REDIRECT, s(r.type, n, f.value))
      end
    end

    # @return [AST] type :PIPELINE or :CMD
    def _pipeline
      commands = [_command]

      while match? :PIPE
        advance

        _skip_whitespace

        if match?(*WORDS, *REDIRECTS)
          commands << _command
        else
          error "expected a command after `|`"
        end
      end

      return commands.first if commands.size == 1

      s(:PIPELINE, *commands)
    end

    # Run the parser interactively, i.e, run a loop and parse user input.
    def self.interactive
      while line = Msh::Readline.readline("parser> ")
        case line
        when "q", "quit", "exit"
          puts "goodbye! <3"
          return
        else
          begin
            parser = Msh::Parser.new line
            p parser.parse
          rescue Errors::ParseError => e
            puts e.message
          end
        end
      end
    end

    # Parse each file passed as input (if any), or run interactively
    def self.start args = ARGV
      return Msh::Parser.interactive if args.empty?

      args.each do |file|
        raise Errors::ParseError, "#{file} is not a file!" unless File.file?(file)

        parser = Msh::Parser.new File.read(file)
        p parser.parse
      end
    end
  end
end
#+-------------------------------------

#+----------------- `lib/msh/pipe.rb`
class Pipeline
  attr_reader :cmds

  Piped = Struct.new :cmd, :in, :out, :close_in, :close_out, :status, :pid do
    alias_method :close_in?, :close_in
    alias_method :close_out?, :close_out
  end

  def initialize cmds
    @cmds = cmds.map do |cmd|
      Piped.new cmd, $stdin, $stdout, false, false
    end

    @cmds.each_cons(2) do |(left, right)|
      right.in, left.out = IO.pipe
      right.close_in = true
      left.close_out = true
    end
  end

  def run
    pids = []
    exit_code = nil
    @cmds.each_with_index do |cmd, _index|
      cmd.pid = fork do
        $stdin.reopen  cmd.in
        $stdout.reopen cmd.out

        raise "need block" unless block_given?

        exit_code = yield cmd

        next # we only hit this if we don't `exec`
      end
      pids << cmd.pid

      cmd.in.close  if cmd.close_in?
      cmd.out.close if cmd.close_out?

      Process.wait cmd.pid
      cmd.status = $CHILD_STATUS&.exitstatus || exit_code
    end
  end
end

# ruby lib/msh/pipe.rb
# if $PROGRAM_NAME == __FILE__
#   commands = %w[fortune rev cowsay]

#   p = Pipeline.new commands
#   p.run { |c| exec(*c.cmd) }
# end
#+-----------------------------------

#+----------------- `lib/msh/interpreter.rb`
# rubocop:disable Style/SpecialGlobalVars









module Msh
  # The interpreter executes an AST.
  #
  # @example
  #     msh = Msh::Interpreter.new
  #     msh.interpret "echo hi from msh!" #=> 0
  #
  # == command substitution
  #
  # TODO
  #
  # Command substitution substitutes text inside `$(text)` as standard out of
  # running msh recursively with `text` as input.
  #
  # ```
  # echo $(echo UP | tr '[:upper:]' '[:lower:]') #=> `up`
  # ```
  #
  # The older backticks style is supported, but
  #
  # == ruby interpolation
  #
  # Ruby interpolation is allowed anywhere using the familiar `#{}` syntax.
  # It is evaluated into WORDs, i.e, it can be used wherever command
  # substitution is allowed.
  #
  # ```
  # echo #{1 + 1} #=> 2
  # ```
  # == subshells
  #
  # TODO
  #
  # Subshells are the same as those in sh, i.e, they work like command
  # substitution, but run don't return any output.
  #
  # ```
  # (exit 1) #=> only exits the subshell, not the current shell
  # ```
  # == what's in a WORD? that which..
  #
  # A command shell's main job is to execute commands. A "command" is just a
  # series of WORD-like tokens, with optional redirections.
  #
  # These WORD-like tokens can be regular literals, string interpolation,
  # subshells, single and double quotes, or command substitution.
  #
  # Expansions occur just before the word is used.
  #
  # == command resolution
  #
  # Commands are resolved by checking if any of the following match, in order
  #
  #   1. aliases
  #   1. functions / builtins
  #   1. executables
  #
  # If any match, the first match is used as the command. If any of the three
  # aren't matched, then the command is unresolved, or _not found_.
  #
  class Interpreter
    include Msh::Logger

    # `AST::Processor::Mixin` defines the following for us
    #
    # ```
    #  def process(node)      #=> calls method `on_TOKEN` for node type TOKEN
    #  def process_all(nodes) #=> nodes.map { |n| process n }
    # ```
    #
    # Each `on_TOKEN` type is responsible for handling its children. This
    # allows `process` to recursively traverse the AST.
    # include ::AST::Processor::Mixin
    def process node
      return if node.nil?

      meth = :"on_#{node.type}"
      return send(meth, node) if respond_to?(meth)

      handler_missing node
    end

    # def process_all *nodes
    def process_all node
      node.to_a.map { |n| process n }
    end

    # create nodes with `s(:TOKEN, ...)`
    include AST::Sexp

    Redirect = Struct.new :io, :dup, :file

    def initialize
      @evaluator = Evaluator.new
      @local_sh_variables = {}
      Config.load!
      setup_manpath!
    end

    # @param code [String]
    def interpret code
      parser = Parser.new code
      process parser.parse
    end

    # @return [String]
    def prompt
      @evaluator.call_no_exit_value :prompt
    end

    # Called on unknown node types
    def handler_missing node
      error "no handler for node: #{node}"
    end

    # @param node [Msh::AST::Node] :PROG
    # @return [Integer] exit status
    def on_PROG node
      process_all(node).last
    end

    # @return [Integer] exit status
    def on_NOOP _node
      @last_command_status = 0
    end

    # @param node [Msh::AST::Node] :COMMAND, :PIPELINE
    # @return [Integer] exit status
    def on_EXPR node
      @last_command_status = process_all(node).last
    end

    # Run commands in a pipeline, i.e, in parallel with connected io streams.
    #
    # Every command is a pipeline of size 1 - this consolidates the logic.
    #
    # @param node [Msh::AST::Node] :PIPELINE
    # @return [Integer] exit status
    def on_PIPELINE node
      p = Pipeline.new node.children
      p.run { |c| process c.cmd }

      $?.exitstatus
    end

    # @param node [Msh::AST::Node] :OR
    # @return [Integer] exit status
    def on_OR node
      process node.children.first
      return $? if $?.exitstatus.zero?

      process node.children.last
    end

    # @param node [Msh::AST::Node] :AND
    # @return [Integer] exit status
    def on_AND node
      process node.children.first
      return $? unless $?.exitstatus.zero?

      process node.children.last
    end

    # @param node [Msh::AST::Node] :CMD
    # @return [Msh::AST::Node] :PIPELINE
    def on_CMD node
      parts        = node.children.group_by(&:type)
      words        = process_all(parts[:WORD]).reject(&:empty?)       # [a, b]
      assignments  = process_all(parts[:ASSIGN]).reduce({}, :merge)   # {a=>b}

      if words.empty?
        local_sh_variables.merge! assignments
        return 0
      end

      prev_env = assignments.merge(local_sh_variables)
                            .transform_values { |v| ENV[v] }

      # r.map { |fd| "fd ##{fd.fileno}, open: #{!fd.closed?}" }
      redirections = process_all(parts[:REDIRECT]).flatten

      begin
        ENV.merge! assignments.merge(local_sh_variables)

        if @evaluator.has?(words.first)
          exec_builtin words, redirections
        else
          exec_command words, redirections
        end
      ensure
        redirections.each do |redirect|
          redirect.file.close
          redirect.io.reopen redirect.dup
        end

        ENV.merge! prev_env
      end
    end

    # @param node [Msh::AST::Node]
    # @return [String]
    def on_WORD node
      process_all(node).join
    end

    # @param node [Msh::AST::Node]
    # @return [String]
    def on_LIT node
      node.children.first
    end

    # @return [String]
    def on_LAST_STATUS _node
      return @last_command_status if @last_command_status

      warn "no last command to retrieve status for"

      ""
    end

    # @return [String]
    def on_SUB _node
      error "unimplemented"
    end

    # @param node [Msh::AST::Node]
    # @return [String]
    def on_ASSIGN node
      var, value = *process_all(node)
      {var => value}
    end

    # @param node [Msh::AST::Node]
    # @return [String]
    def on_VAR node
      var = node.children.first[1..-1]

      local_value = local_sh_variables.dig(var)
      return local_value if local_value

      ENV[var].to_s
    end

    # @param node [Msh::AST::Node]
    # @return [String]
    def on_INTERP node
      value = node.children.first[2..-2]
      begin
        @evaluator.eval(value) || ""
      rescue NoMethodError => e
        error e.message
      end
    end

    # @param node [Msh::AST::Node]
    # @return [Array<Array<IO>>]
    def on_REDIRECT node
      process_all(node)
    end

    # @param node [Msh::AST::Node]
    # @return [Array<IO>]
    def on_REDIRECT_OUT node
      file_descriptor, output = node.children
      io = IO.new(file_descriptor, "r")
      dup = io.dup
      file = File.open output, "w"

      io.reopen file, "w"

      Redirect.new io, dup, file
    end

    # @param node [Msh::AST::Node]
    # @return [Array<IO>]
    def on_REDIRECT_IN node
      file_descriptor, output = node.children
      io = IO.new(file_descriptor, "r")
      dup = io.dup
      file = File.open output, "r"

      io.reopen file

      Redirect.new io, dup, file
    end

    # @param node [Msh::AST::Node]
    # @return [Array<IO>]
    def on_APPEND_OUT node
      file_descriptor, output = node.children
      io = IO.new(file_descriptor, "r")
      dup = io.dup
      file = File.open output, "a"

      io.reopen file

      Redirect.new io, dup, file
    end

    # @param node [Msh::AST::Node]
    # @return [Array<IO>]
    def on_AND_REDIRECT_RIGHT node
      file_descriptor, output = node.children

      r = process s(:REDIRECT_OUT, file_descriptor, output)
      # r.io.sync = true

      err_io = IO.new(2)
      dup    = err_io.dup
      err_io.reopen r.io # , "a"

      err = Redirect.new err_io, dup, r.file

      # err_r = process(s(:APPEND_OUT, 2, r.file.dup))
      # err_r.io.sync = true

      [r, err]
    end

    private

    attr_reader :local_sh_variables

    def exec_builtin words, _redirections
      @evaluator.call(*words)
    rescue ArgumentError => e
      puts e.message
    end

    def exec_command words, _redirections
      @evaluator.call(:run, *words)
    end

    # @param msg [String]
    def error msg
      raise Errors::InterpreterError, msg
    end

    # Add Msh's manpages to the current MANPATH
    #
    # @todo: what the "::" means (need it to work)
    def setup_manpath!
      manpaths = ENV["MANPATH"].to_s.split(File::PATH_SEPARATOR)
      manpaths << File.join(Msh.root, "man").to_s
      ENV["MANPATH"] = manpaths.compact.join(File::PATH_SEPARATOR) + "::"
    end
  end
end

# rubocop:enable Style/SpecialGlobalVars
#+------------------------------------------

#+----------------- `lib/msh/cli.rb`
module Msh
  module CLI
    BANNER = <<-B
Usage:
    msh [options]... [file]...

Options:
    B

    # @return [OptionParser]
    def self.option_parser
      OptionParser.new do |opts|
        opts.banner = Msh::CLI::BANNER

        opts.on "-h", "--help", "print this help" do
          puts opts
          exit 2
        end

        opts.on "-V", "--version", "show the version   (#{Msh::VERSION})" do
          puts "msh version #{Msh::VERSION}"
          exit 2
        end

        opts.on "-c", "--command", "runs a string as shell input" do |cmd_string|
          abort "missing argument: -c" if cmd_string == ""

          interpreter = Msh::Interpreter.new
          exit interpreter.interpret cmd_string
        end
      end
    end

    # @todo configure Msh::Config here, if needed
    def self.handle_options!
      option_parser.parse!
    rescue OptionParser::MissingArgument, OptionParser::InvalidOption => e
      abort e.message
    end
  end
end
#+----------------------------------

#+----------------- `lib/msh/repl.rb`
module Msh
  # A read-eval print loop (REPL), continuously reads in user input, then
  # executes it.
  #
  # This is separate from an interpreter, which is only responsible for
  # interpreting (i.e, executing) code. For instance, the interpreter is still
  # responsible for the non-term specific things, such as the user's prompt,
  # but the REPL then needs to print that prompt.
  #
  # ```
  # Repl.new # start up a new REPL
  # ```
  class Repl
    # @return [Interpreter]
    attr_reader :interpreter

    def initialize
      @interpreter = Msh::Interpreter.new
      puts "Welcome to msh v#{Msh::VERSION} (`?` for help)" if $stdin.tty?

      with_interrupt_handling do
        input_loop do |line|
          add_to_history line
          interpreter.interpret line
        end
      end
    end

    private

    # mruby has no interrupts
    def with_interrupt_handling &block
      if RUBY_ENGINE == "mruby"
        with_interrupt_handling_mruby(&block)
      else
        with_interrupt_handling_ruby(&block)
      end
    end

    def with_interrupt_handling_ruby
      yield
    rescue Interrupt
      puts "^C"
      exit 0
    end

    def with_interrupt_handling_mruby
      yield
    end

    # @yield [String] the next line of input
    def input_loop
      get_line = if !$stdin.tty? || ENV["NO_READLINE"]
                   -> { ARGF.gets&.chomp }
                 else
                   -> { Msh::Readline.readline(interpreter.prompt) }
                 end

      while line = get_line.call
        yield line
      end
    end

    def add_to_history line
      Msh::Readline.add_to_history line
    end
  end
end
#+-----------------------------------

#+----------------- `lib/msh/msh.rb`
# == name
#
# msh - a ruby shell
#
# == synopsis
#
# *msh* [_options_]... [_file_]...
#
# == description
#
# Msh is a shell that shares Ruby's goal
#
# [quote, Yukihiro Matsumoto]
# ____
# For me the purpose of life is partly to have joy. Programmers often feel
# joy when they can concentrate on the creative side of programming, So Ruby
# is designed to make programmers happy.
# ____
#
# It supports a subset of `sh`/`bash`, basically just the _essential_ parts.
#
#
# ```
#        feature                       example
# ┌───┬─────────────────────────────┬──────────────────────────────────────┐
# │ ✓ │ redirect output             │ a > b                                │
# │ ✓ │ append output               │ a >> b                               │
# │ ✓ │ redirect input              │ a < b                                │
# │ ✓ │ redirect to file descriptor │ a 2>&1                               │
# │ ✓ │ conditionals                │ a || b && c                          │
# │ ✓ │ commands                    │ a; b;                                │
# │   │ grouping                    │ a; {b || c}                          │
# │   │ subshells                   │ (a)                                  │
# │ ✓ │ pipes                       │ a | b                                │
# │   │ command substitution        │ $(a 'b' c)                           │
# │   │ process substitution        │ <(a | b)                             │
# │   │ local variables             │ a = 2                                │
# │   │ variable interpolation      │ echo $HOME                           │
# │ ✓ │ environment variables       │ a=b a b                              │
# │   │ aliases                     │ alias g = 'git'                      │
# │ ✓ │ functions                   │ repl "def foo; puts :bar; end"; foo  │
# └───┴─────────────────────────────┴──────────────────────────────────────┘
# ```
#
# It allows for interpolation in words
#
# ```
# $ echo π ≈ #{Math::PI} | cowsay
#  _________________________
# < π ≈ 3.141592653589793 . >
#  -------------------------
#         \   ^__^
#          \  (oo)\_______
#             (__)\       )\/\
#                 ||----w |
#                 ||     ||
# ```
#
# The underlying REPL is available via the `repl` builtin. It's the same
# context as used during interpolation.
#
#
# ```
# $ repl
# enter some ruby (sorry, no multiline)
# > def foo; "bar"; end
# => :foo
# > ^D
# $ echo foo#{foo}
# foo bar
# $ echo #{self}
# <Msh::Context:0x0000557a7f0b6f68>
# ```
#
# Functions are just method calls on that same REPL context.
#
# == Examples
#
# Filter commands
#
# ```
# $ repl
# enter some ruby (sorry, no multiline)
# > def upcase; ARGF.each_line { |l| puts l.upcase }; end
# => :upcase
# > ^D
# $ echo hi | upcase
# HI
# ```
#
# Changing the prompt
#
# ```
# $ repl
# enter some ruby (sorry, no multiline)
# > def prompt; "% "; end
# => "% "
# > ^D
# %
# ```
#
# === todo
#
# - source
# - config file
#
# ```
# $ source file.msh
# ```
# == options
#
# *-h, --help*::
#   Show usage information.
#
# *-V, --version*::
#   Show the version.
#
# *--copyright, --license*::
#   Show the copyright.
#
# *-c <command>*::
#   Run a command string as input.
#
# == copying
#
# Copyright \(C) 2020 Mark Delk.
# Free use of this software is granted under the terms of the MIT License.
#
# == resources
#
# *issue tracker*:: https://github.com/jethrodaniel/msh/issues?q=is%3Aopen.
# *source code*:: https://github.com/jethrodaniel/msh
#
module Msh
  def self.root
    lib = File.dirname(File.realpath(__FILE__)) # rubocop:disable Style/Dir
    File.realpath(File.join(lib, ".."))
  end

  # Entry point for the `msh` command.
  #
  # Parses options/commands, then runs either interactively or on files.
  def self.start
    Msh::CLI.handle_options!

    return Msh::Repl.new if ARGV.size.zero?

    interpreter = Msh::Interpreter.new

    ARGV.each do |file|
      abort "`#{file}` not found" unless File.file?(file)
      interpreter.interpret File.read(file)
    end
  end
end
#+----------------------------------

# Consolidate files into a single executable via
#
#     ruby ./bin/consolidate gem/entry/path.rb >exe && chmod u+x exe && ./exe
#
# To see the dependency graph
#
#     ruby ./bin/consolidate gem/entry/path.rb >exe && chmod u+x exe && ./exe
#
Msh.start if $0 == __FILE__

