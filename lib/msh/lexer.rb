#--
# DO NOT MODIFY!!!!
# This file is automatically generated by rex 1.0.7
# from lexical definition file "lib/msh/parse.l".
#++

require 'racc/parser'
# vim: set ft=ruby:

# msh's rex lexer.
#
# Racc uses tokens like this
#
# ```
# # [:type, value]
# [:number, "3.145"]
# ```
#
# Scroll to the bottom to see usage, etc.

class Msh::Lexer < Racc::Parser
      require 'strscan'

      class ScanError < StandardError ; end

      attr_reader   :lineno
      attr_reader   :filename
      attr_accessor :state

      def scan_setup(str)
        @ss = StringScanner.new(str)
        @lineno =  1
        @state  = nil
      end

      def action
        yield
      end

      def scan_str(str)
        scan_setup(str)
        do_parse
      end
      alias :scan :scan_str

      def load_file( filename )
        @filename = filename
        File.open(filename, "r") do |f|
          scan_setup(f.read)
        end
      end

      def scan_file( filename )
        load_file(filename)
        do_parse
      end


        def next_token
          return if @ss.eos?

          # skips empty actions
          until token = _next_token or @ss.eos?; end
          token
        end

        def _next_token
          text = @ss.peek(1)
          @lineno  +=  1  if text == "\n"
          token = case @state
            when nil
          case
                  when (text = @ss.scan(/[ \t]+/))
                    ;

                  when (text = @ss.scan(/\#[^\n]*[\n]*/))
                    ;

                  when (text = @ss.scan(/[\n]+/))
                     action {
                          @line += 1
                          @column = 1
                          [:NEWLINE, text]
                        }


                  when (text = @ss.scan(/time/))
                     action { [:TIME, text] }

                  when (text = @ss.scan(/;/))
                     action { [:SEMI, text] }

                  when (text = @ss.scan(/\-p/))
                     action { [:TIME_OPT, text] }

                  when (text = @ss.scan(/\{/))
                     action { [:LEFT_BRACE, text] }

                  when (text = @ss.scan(/\}/))
                     action { [:RIGHT_BRACE, text] }

                  when (text = @ss.scan(/\(/))
                     action { [:LEFT_PAREN, text] }

                  when (text = @ss.scan(/\)/))
                     action { [:RIGHT_PAREN, text] }

                  when (text = @ss.scan(/!/))
                     action { [:BANG, text] }

                  when (text = @ss.scan(/\d+/))
                     action { [:DIGIT, text.to_i] }

                  when (text = @ss.scan(/((\\[\s;&\|<>\{\}\(\)]|[^\s\n&\|;<>\{\}\(\)])+)/))
                     action { [:WORD, text] }

                  when (text = @ss.scan(/<>/))
                     action { [:DIAMOND, text] }

                  when (text = @ss.scan(/<\&/))
                     action { [:DUP_IN, text] }

                  when (text = @ss.scan(/>\&/))
                     action { [:DUP_OUT, text] }

                  when (text = @ss.scan(/>>/))
                     action { [:D_REDIRECT_RIGHT, text] }

                  when (text = @ss.scan(/>/))
                     action { [:REDIRECT_RIGHT, text] }

                  when (text = @ss.scan(/<</))
                     action { [:D_REDIRECT_LEFT, text] }

                  when (text = @ss.scan(/</))
                     action { [:REDIRECT_LEFT, text] }

                  when (text = @ss.scan(/\|\|/))
                     action { [:OR, text] }

                  when (text = @ss.scan(/\|&/))
                     action { [:PIPE_AND, text] }

                  when (text = @ss.scan(/\|/))
                     action { [:PIPE, text] }

                  when (text = @ss.scan(/&&/))
                     action { [:AND_AND, text] }

                  when (text = @ss.scan(/&/))
                     action { [:AND, text] }

                  when (text = @ss.scan(/&\>/))
                     action { [:AND_REDIRECT_RIGHT, text] }

                  when (text = @ss.scan(/&\>\>/))
                     action { [:AND_D_REDIRECT_RIGHT, text] }

                  when (text = @ss.scan(/\".*\"/))
                     action { [:DOUBLE_QUOTE_STR, text.gsub(/^"|"$/, '')] }

                  when (text = @ss.scan(/\'.*\'/))
                     action { [:SINGLE_QUOTE_STR, text.gsub(/^'|'$/, '')] }

          
          else
            text = @ss.string[@ss.pos .. -1]
            raise  ScanError, "can not match: '" + text + "'"
          end  # if

        else
          raise  ScanError, "undefined state: '" + state.to_s + "'"
        end  # case state
          token
        end  # def _next_token

  attr_reader :line, :column
  def initialize
    @line = 1
    @column = 1
  end
  def tokenize code
    scan_setup code
    tokens = []
    while token = next_token
      tokens << token
    end
    tokens
  end
  def next_token
    return if @ss.eos?
    until token = _next_token or @ss.eos?; end
    case token
    when :NEWLINE
      @line += 1
      @column = 1
    else
      @column += token&.last&.size || 1
    end
    token
  rescue ScanError => e
    raise e
  end
end # class

require "msh/version"
require "msh/configuration"

# TODO: why isn't the config enough to require this?
require "optparse"

class Msh::Lexer::ScanError
  # Make rex's error message more friendly
  #
  # ```
  # --> spec/fixtures/bad/lex.sh:2:4
  #
  #  1 | fortune | cowsay -f
  #  2 | wow %
  #      ---^
  #         | cannot tokenize "%\n"
  # ```
  #
  # @param rex [Racc::Parser]
  def pretty_message rex
    token = message.delete_prefix("can not match: '").delete_suffix("'")

    # show a few lines from the file surrounding the error
    if rex.filename
      msg = "\n--> #{rex.filename}:#{rex.line}:#{rex.column}\n"

      rex.string.split("\n").each_with_index do |line, index|
        if rex.line - index + 1 <= 3
          msg += "\n  #{index + 1} | #{line}"
        end
      end

      msg += "\n      "
      (rex.column - 1).times { msg += "-" }
      msg += "^"
      msg += "\n     #{' ' * rex.column}| cannot tokenize #{token.inspect}\n"
    else
      msg = "error: cannot tokenize #{token.inspect}\n"
    end

    msg
  end
end

class Msh::Lexer
  def string
    @ss.string
  end

  def self.interactive
    while line = Readline.readline("lexer> ", true)&.chomp
      case line
      when "q", "quit", "exit"
        puts "goodbye! <3"
        exit
      else
        begin
          rex = Msh::Lexer.new
          rex.instance_eval { scan_setup line }

          while token = rex.next_token
            p token
          end
        rescue Msh::Lexer::ScanError => e
          puts e.pretty_message(rex)
        end
      end
    end
  end

  # Run the lexer on a file
  def self.lex_file filename
    rex = Msh::Lexer.new
    rex.load_file filename
    while token = rex.next_token
      p token
    end
  rescue Msh::Lexer::ScanError => e
    raise e.class.new, e.pretty_message(rex)
  end

  def self.start args = ARGV
    # Lex each file passed as input
    if args.size.positive?
      args.each do |file|
        abort "#{file} is not a file!" unless File.file?(file)

        begin
          Msh::Lexer.lex_file file
        rescue Msh::Lexer::ScanError => e
          abort e.message
        end
      end
    else
      Msh::Lexer.interactive
    end
  end
end
