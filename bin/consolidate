#!/usr/bin/env ruby
# vim: set filetype=ruby:

# Simple tool to generate a single ruby file from a Ruby gem, by resolving
# `require`s, similar to combining c/c++ header files without duplication.
#
# Consolidate files into a single executable via
#
#     $ consolidate lib/msh.rb > exe
#
# To see the dependency graph
#
#     $ ruby bin/consolidate.rb lib/msh.rb >/dev/null
#     => English              (stdlib) English
#       => msh/backports              lib/msh/backports.rb
#       => msh/core_extensions        lib/msh/core_extensions.rb
#           => msh/version            lib/msh/version.rb
#         => msh/optparse             lib/msh/optparse.rb
#           => logger                 (stdlib) logger
#             => msh/errors           lib/msh/errors.rb
#             => msh/ansi             lib/msh/ansi.rb
#

require "parser/current"

class RequireResolver < Parser::TreeRewriter
  STD_LIBS = %w[
    English
    logger
    reline
    e2mmap
    ripper
    fileutils
    jruby
    readline
    io/console
    timeout
    forwardable
    pathname
    tempfile
    fiddle/import
    win32api
  ].freeze

  def consolidate file, parser, files
    @files = files
    @parser = parser.tap(&:reset)
    buffer = Parser::Source::Buffer.new("(#{file})")
    buffer.source = File.read(file)
    ast = @parser.parse(buffer)
    rewrite(buffer, ast)
  end

  # $ ruby-parse -e "require 'ast'"
  # (send nil :require
  #   (str "ast"))
  #
  def on_send node
    return unless node.children[1] == :require && node.children[2].type == :str

    lib = node.children[2].children[0]
    warn "=> #{lib}#{' (stdlib)' if stdlib?(lib)}"

    return if stdlib?(lib)

    req_path = @files[node.children.last.children.last]

    if req_path.visited?
      remove(node.location.expression)
      return
    end

    req_path.visited = true
    req_file = req_path.path

    consolidator = RequireResolver.new
    req_contents = consolidator.consolidate(req_file, @parser, @files)

    replace node.location.expression, "\n#{req_contents}\n"
  end

  private def stdlib? lib
    RequireResolver::STD_LIBS.include? lib
  end
end

RequirePath = Struct.new(:path, :visited) do
  def visited?
    visited
  end
end

class GemConsolidator
  def initialize gem_entry, footer: nil
    @gem_entry = gem_entry
    @name      = File.basename(@gem_entry).delete_suffix(".rb")
    @lib_dir   = Pathname.new(File.dirname(@gem_entry))
    @gem_root  = @lib_dir + ".."
    gemspec    = @gem_root + "#{@name}.gemspec"
    Dir.chdir(@gem_root) do
      @gem = Gem::Specification.load(gemspec.to_s)
    end

    @files = @gem.files.filter_map do |f|
      pre = @gem.require_paths.find { |p| f.start_with?(p) }

      if pre
        req = f.delete_prefix("#{pre}/").delete_suffix(".rb")
        path = Pathname.new(@gem_root) + f
        {req => RequirePath.new(path)}
      end
    end.reduce(:merge)

    @parser = Parser::CurrentRuby.new

    @footer = footer
  end

  def self.run gem_entry
    new(gem_entry).run
  end

  def run
    consolidator = RequireResolver.new
    single_file = consolidator.consolidate(@gem_entry, @parser, @files)
    [single_file, @footer].join("\n")
  end
end

if $PROGRAM_NAME == __FILE__
  consolidator = GemConsolidator.new(ARGV[0], :footer => "Msh.start if $0 == __FILE__")
  puts consolidator.run
end
