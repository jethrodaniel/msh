#!/usr/bin/env ruby
# vim: set filetype=ruby:

# Simple tool to generate a single ruby file from a Ruby gem, by resolving
# `require`s, similar to combining c/c++ header files without duplication.
#
# Consolidate files into a single executable via
#
#     $ consolidate lib/msh.rb > exe
#
# To see the dependency graph
#
#     $ ruby bin/consolidate.rb lib/msh.rb >/dev/null
#     => English              (stdlib) English
#       => msh/backports              lib/msh/backports.rb
#       => msh/core_extensions        lib/msh/core_extensions.rb
#           => msh/version            lib/msh/version.rb
#         => msh/optparse             lib/msh/optparse.rb
#           => logger                 (stdlib) logger
#             => msh/errors           lib/msh/errors.rb
#             => msh/ansi             lib/msh/ansi.rb
#
# See https://blogs.grammatech.com/visualizing-include-graphs

require "bundler/inline"

gemfile do
  gem "parser", "~> 2.7"
  gem "pry-byebug"
end

require "parser/current"

class Require
  include AST::Processor::Mixin

  STD_LIBS = %w[
    English
    logger
    reline
    e2mmap
    ripper
    fileutils
    jruby
    readline
  ].freeze

  def initialize lib, indent = 0, files = []
    @lib = lib
    @indent = indent
    @files = files
  end

  def indent
    @indent += 2
  end

  def dedent
    @indent -= 2 unless @indent.zero?
  end

  # s(:send, nil, :require,
  #   s(:str, "parser/current"))
  def on_send node
    if node.children[1] == :require && node.children[2].type == :str
      required = node.children[2].children[0]
      handle_require required
    end
    node
  end

  # recurse on the new require'd file
  def handle_require require_stmt
    first_part, *rest = *require_stmt.split("/")
    lib = @lib.dup
    gem_name = File.basename(File.dirname(@lib))

    file_name = require_stmt
    file_name = File.join(gem_name, file_name) unless file_name.start_with?(gem_name)

    file = (@lib + file_name).sub_ext(".rb")

    if STD_LIBS.include? require_stmt
      puts "require '#{require_stmt}' unless RUBY_ENGINE == 'mruby'\n"
      warn "#{' ' * @indent}=> #{require_stmt.ljust(20, ' ')}\t(stdlib) #{require_stmt}"
      return
    end

    # Don't traverse the same file more than once.
    #
    # Also prevents looping indefinately if file `a.rb` contains `require "a"`
    return if @files.include?(file)

    indent

    Require.new(lib, @indent, @files << file).process(Parser::CurrentRuby.parse(File.read(file)))

    header = "\n#+----------------- `#{file}`"
    puts header

    warn "#{' ' * @indent}=> #{require_stmt.ljust(20, ' ')}\t#{file}"

    out = File.read(file)
    non_std_libs = out.scan(/[\s]*require (?<req>[^\n]*)$/).reject { |req| STD_LIBS.include?(req) }
    non_std_libs.each do |req|
      out.gsub! "require #{req.first}", ""
    end
    puts out.strip
    puts "#+#{'-' * (header.size - 3)}\n"

    dedent
  end

  def handler_missing node
    node.children.each do |child|
      process child if child.respond_to?(:type) && child.respond_to?(:children)
    end
  end
end

if $PROGRAM_NAME == __FILE__
  file = File.read ARGV[0]
  lib = Pathname.new(File.dirname(ARGV[0]))

  header = <<~RB
    #!/usr/bin/env ruby
  RB
  footer = <<~RB
    Msh.start if $0 == __FILE__
  RB

  puts <<~RB
    #{header}

    # Autogenerated single-file version of `#{ARGV[0]}`.
    #
    # Each file is present below, but
    #
    # - standard library `require`s are moved to **before** the file. TODO: fix this.
    # - `require`s for non-standard library files are absent (obviously)
    #
    # **Note**: currently, only the following structure is allowed
    #
    #     lib
    #     ├── foo
    #     │     ├── version.rb
    #     │     └── foo.rb
    #     └── foo.rb
    #
    # Also, the gem entry point (`lib/foo.rb` in the above) must **only**
    # contain `require` statements, since it's content (besides it's
    # `require`s) won't be in the consolidated file.
    #
  RB

  ast = Parser::CurrentRuby.parse(file)
  Require.new(lib).process(ast)

  puts footer
end
