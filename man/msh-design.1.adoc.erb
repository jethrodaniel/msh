= msh-design(1)
<%= Msh::Documentation.prelude %>

== name

design - msh's design and goals

== synopsis

*design*

== goals

- be simple
- be friendly

== design

Msh is, in some ways, a result of PTSD from shells like Bash or _sh_.

Notably horric things about _those_ shells

- lexing, parsing, and interpretation are not distinct phases (torn on this)
- parameter expansion _${expression}_
- _case_ syntax
- functions and parameters_$1_, etc
- variables (global by default, no space before _=_, etc)

Msh tries to keep things simple, and uses Ruby to do most of that

- functions are just Ruby methods
- variables are just Ruby variables

=== Example

When Msh executes the following code

   echo the time is #{Time.now} | cowsay

The following steps are performed

==== 1. Preprocessing

The code is evaluated as a Ruby string, to allow for interpolation via _#{}_.

    echo the time is 2020-03-21 16:39:28 -0500 | cowsay

==== 2. Lexing

The input is converted into tokens.

    [:WORD, "echo"]
    [:WORD, "the"]
    [:TIME, "time"]
    [:WORD, "is"]
    [:WORD, "2020-03-21"]
    [:WORD, "16:39:28"]
    [:WORD, "-0500"]
    [:PIPE, "|"]
    [:WORD, "cowsay"]

==== 3. Parsing

The tokens are converted into an abstract syntax tree (AST).

    s(:EXPR,
      s(:PIPELINE,
        s(:COMMAND,
          s(:WORD, "echo"),
          s(:WORD, "the"),
          s(:WORD, "time"),
          s(:WORD, "is"),
          s(:WORD, "2020-03-21"),
          s(:WORD, "16:39:28"),
          s(:WORD, "-0500")),
        s(:COMMAND,
          s(:WORD, "cowsay"))))

==== 4. Interetation

The AST is executed by a tree-walking interpretor.

```
     _______________________________________
    < the time is 2020-03-21 16:39:28 -0500 >
     ---------------------------------------
            \   ^__^
             \  (oo)\_______
                (__)\       )\/\
                    ||----w |
                    ||     ||
```

== msh

Part of msh(1).
