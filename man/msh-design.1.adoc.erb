= msh-design(1)
<%= Msh::Documentation.prelude %>

== name

design - msh's design and goals

== synopsis

*design*

== goals

- be simple
- be friendly

== design

Msh is, in some ways, a result of PTSD from shells like Bash or _sh_.

Notably horric things about _those_ shells

- lexing, parsing, and interpretation are not distinct phases
- parameter expansion _${expression}_
- _case_ syntax
- functions and parameters_$1_, etc
- variables (global by default, no space before _=_, etc)

Msh tries to keep things simple, and uses Ruby to do most of that

- functions are just Ruby methods
- variables are just Ruby variables

=== example

When Msh executes the following code

  echo the time is #{Time.now} | cowsay

The following steps are performed

==== Preprocessing

The code is evaluated as a Ruby string, to allow for interpolation via _#{}_.

==== Lexing

The input is converted into tokens.

==== Parsing

The tokens are converted into an abstract syntax tree (AST).

==== Interetation

The AST is executed by a tree-walking interpretor.

== msh

Part of msh(1).
