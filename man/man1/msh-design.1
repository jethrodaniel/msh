'\" t
.\"     Title: msh-design
.\"    Author: Copyright 2020, Mark Delk under the terms of the MIT license
.\" Generator: Asciidoctor 2.0.10
.\"      Date: 2020-03-21
.\"    Manual: Msh Manual
.\"    Source: Msh v0.1.0
.\"  Language: English
.\"
.TH "DESIGN" "1" "2020-03-21" "Msh v0.1.0" "Msh Manual"
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.ss \n[.ss] 0
.nh
.ad l
.de URL
\fI\\$2\fP <\\$1>\\$3
..
.als MTO URL
.if \n[.g] \{\
.  mso www.tmac
.  am URL
.    ad l
.  .
.  am MTO
.    ad l
.  .
.  LINKSTYLE blue R < >
.\}
.SH "NAME"
design \- msh\(aqs design and goals
.SH "SYNOPSIS"
.sp
\fBdesign\fP
.SH "GOALS"
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
be simple
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
be friendly
.RE
.SH "DESIGN"
.sp
Msh is, in some ways, a result of PTSD from shells like Bash or \fIsh\fP.
.sp
Notably horric things about \fIthose\fP shells
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
lexing, parsing, and interpretation are not distinct phases (torn on this)
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
parameter expansion \fI${expression}\fP
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\fIcase\fP syntax
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
functions and parameters_$1_, etc
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
variables (global by default, no space before \fI=\fP, etc)
.RE
.sp
Msh tries to keep things simple, and uses Ruby to do most of that
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
functions are just Ruby methods
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
variables are just Ruby variables
.RE
.SS "Example"
.sp
When Msh executes the following code
.sp
.if n .RS 4
.nf
echo the time is #{Time.now} | cowsay
.fi
.if n .RE
.sp
The following steps are performed
.SS "1. Preprocessing"
.sp
The code is evaluated as a Ruby string, to allow for interpolation via \fI#{}\fP.
.sp
.if n .RS 4
.nf
echo the time is 2020\-03\-21 16:39:28 \-0500 | cowsay
.fi
.if n .RE
.SS "2. Lexing"
.sp
The input is converted into tokens.
.sp
.if n .RS 4
.nf
[:WORD, "echo"]
[:WORD, "the"]
[:TIME, "time"]
[:WORD, "is"]
[:WORD, "2020\-03\-21"]
[:WORD, "16:39:28"]
[:WORD, "\-0500"]
[:PIPE, "|"]
[:WORD, "cowsay"]
.fi
.if n .RE
.SS "3. Parsing"
.sp
The tokens are converted into an abstract syntax tree (AST).
.sp
.if n .RS 4
.nf
s(:EXPR,
  s(:PIPELINE,
    s(:COMMAND,
      s(:WORD, "echo"),
      s(:WORD, "the"),
      s(:WORD, "time"),
      s(:WORD, "is"),
      s(:WORD, "2020\-03\-21"),
      s(:WORD, "16:39:28"),
      s(:WORD, "\-0500")),
    s(:COMMAND,
      s(:WORD, "cowsay"))))
.fi
.if n .RE
.SS "4. Interetation"
.sp
The AST is executed by a tree\-walking interpretor.
.sp
.if n .RS 4
.nf
     _______________________________________
    < the time is 2020\-03\-21 16:39:28 \-0500 >
     \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
            \(rs   ^__^
             \(rs  (oo)\(rs_______
                (__)\(rs       )\(rs/\(rs
                    ||\-\-\-\-w |
                    ||     ||
.fi
.if n .RE
.SH "MSH"
.sp
Part of msh(1).
.SH "AUTHOR"
.sp
Copyright 2020, Mark Delk under the terms of the MIT license