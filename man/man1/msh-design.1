'\" t
.\"     Title: msh-design
.\"    Author: Copyright 2020, Mark Delk under the terms of the MIT license
.\" Generator: Asciidoctor 2.0.10
.\"      Date: 2020-03-19
.\"    Manual: Msh Manual
.\"    Source: Msh v0.1.0
.\"  Language: English
.\"
.TH "DESIGN" "1" "2020-03-19" "Msh v0.1.0" "Msh Manual"
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.ss \n[.ss] 0
.nh
.ad l
.de URL
\fI\\$2\fP <\\$1>\\$3
..
.als MTO URL
.if \n[.g] \{\
.  mso www.tmac
.  am URL
.    ad l
.  .
.  am MTO
.    ad l
.  .
.  LINKSTYLE blue R < >
.\}
.SH "NAME"
design \- msh\(aqs design and goals
.SH "SYNOPSIS"
.sp
\fBdesign\fP
.SH "GOALS"
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
be simple
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
be friendly
.RE
.SH "DESIGN"
.sp
Msh is, in some ways, a result of PTSD from shells like Bash or \fIsh\fP.
.sp
Notably horric things about \fIthose\fP shells
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
lexing, parsing, and interpretation are not distinct phases
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
parameter expansion \fI${expression}\fP
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\fIcase\fP syntax
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
functions and parameters_$1_, etc
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
variables (global by default, no space before \fI=\fP, etc)
.RE
.sp
Msh tries to keep things simple, and uses Ruby to do most of that
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
functions are just Ruby methods
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
variables are just Ruby variables
.RE
.SS "example"
.sp
When Msh executes the following code
.sp
.if n .RS 4
.nf
echo the time is #{Time.now} | cowsay
.fi
.if n .RE
.sp
The following steps are performed
.SS "Preprocessing"
.sp
The code is evaluated as a Ruby string, to allow for interpolation via \fI#{}\fP.
.SS "Lexing"
.sp
The input is converted into tokens.
.SS "Parsing"
.sp
The tokens are converted into an abstract syntax tree (AST).
.SS "Interetation"
.sp
The AST is executed by a tree\-walking interpretor.
.SH "MSH"
.sp
Part of msh(1).
.SH "AUTHOR"
.sp
Copyright 2020, Mark Delk under the terms of the MIT license