'\" t
.\"     Title: msh
.\"    Author: [see the "AUTHOR(S)" section]
.\" Generator: Asciidoctor 2.0.10
.\"      Date: 2020-05-11
.\"    Manual: Msh Manual
.\"    Source: Msh v0.1.0
.\"  Language: English
.\"
.TH "MSH" "1" "2020-05-11" "Msh v0.1.0" "Msh Manual"
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.ss \n[.ss] 0
.nh
.ad l
.de URL
\fI\\$2\fP <\\$1>\\$3
..
.als MTO URL
.if \n[.g] \{\
.  mso www.tmac
.  am URL
.    ad l
.  .
.  am MTO
.    ad l
.  .
.  LINKSTYLE blue R < >
.\}
.SH "NAME"
msh \- a ruby shell
.SH "SYNOPSIS"
.sp
\fBmsh\fP [\fIoptions\fP]... [\fIfile\fP]...
.SH "DESCRIPTION"
.sp
It supports a subset of \f(CRsh\fP/\f(CRbash\fP, including
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
redirection \f(CRa 2>&1 > out.log\fP
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
conditionals \f(CRa || b && c\fP
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
commands \f(CRa; b;\fP
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
grouping \f(CRa; {b}\fP
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
subshells \f(CR(a) && {b || c; }\fP
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
pipes \f(CRa | b\fP
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
command substitution \f(CRa \(aqb\(aq c\fP (but use backticks, not single qoutes)
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
process substitution \f(CR<(a | b)\fP
.RE
.sp
It uses Ruby to handle variables, functions, and aliases, and allows for
Ruby interpolation anywhere in the source.
.sp
.if n .RS 4
.nf
$ echo π ≈ #{Math::PI} | cowsay
 _________________________
< π ≈ 3.141592653589793 . >
 \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
        \(rs   ^__^
         \(rs  (oo)\(rs_______
            (__)\(rs       )\(rs/\(rs
                ||\-\-\-\-w |
                ||     ||
.fi
.if n .RE
.sp
Unlike other shells, Msh doesn\(cqt have functions or variables builtin to the
language, rather, it tasks that to it\(cqs host, or implementation, language
(here, Ruby).
.sp
The host language is available via a REPL at with the \f(CRrepl\fP command, and
additionally processes string interpolation in all commands.
.sp
.if n .RS 4
.nf
$ repl
irb> ... quit
$ echo the time is now #{Time.now}
.fi
.if n .RE
.SS "Functions"
.sp
Instead of functions, Msh just calls Ruby methods
.sp
.if n .RS 4
.nf
echo #{def hello name; puts "hello, #{name}"; end}
hello world #=> prints "hello, world"
.fi
.if n .RE
.sp
Similarly, builtins and aliases are just Ruby methods as well.
.sp
.if n .RS 4
.nf
$ builtins
$ aliases
.fi
.if n .RE
.SS "Variables"
.sp
Variables in the REPL correspond directly to environment variables.
.sp
.if n .RS 4
.nf
$ RAILS_ENV=production bundle exec rails
$ repl
irb> RAILS_ENV=\(aqproduction\(aq # this is like `export VAR=...`
$ bundle exec rails
.fi
.if n .RE
.SH "OPTIONS"
.sp
\fB\-h, \-\-help\fP
.RS 4
Show usage information.
.RE
.sp
\fB\-V, \-\-version\fP
.RS 4
Show the version.
.RE
.sp
\fB\-\-copyright, \-\-license\fP
.RS 4
Show the copyright.
.RE
.sp
\fB\-c <command>\fP
.RS 4
Run a command string as input.
.RE
.SH "RESOURCES"
.sp
\fBissue tracker\fP
.RS 4
.URL "https://github.com/jethrodaniel/msh/issues?q=is%3Aopen" "" "."
.RE
.sp
\fBsource code\fP
.RS 4
.URL "https://github.com/jethrodaniel/msh" "" ""
.RE
.SH "MSH"
.sp
Part of msh(1).